
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Archive: 2021/9</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    
    <meta name="author" content="Lee 62"> 
    <link rel="alternative" href="atom.xml" title="Lee 62&#39;s Site" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

    
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

<meta name="generator" content="Hexo 6.3.0"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">Lee 62&#39;s Site</span>
    <div id="loader"></div>
    <div id="single" class="page">
    <div id="top">
        <a class="iconfont icon-left image-icon" href="javascript:history.back()"></a>
    </div>
    <div class="dark-obsidian section">
        <div class="article animated fadeIn">
            <div class="main">
                <div class="content animated fadeIn">
                    <div class="set">
                        <h1 style="text-align: center">Archived</h1>
                        <p style="text-align: center">「 57 」</p>
                        <ul class="timeline timeline-centered">
                            
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">January 2022</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">January 27, 2022</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2022/01/27/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88string%EF%BC%89%E7%9A%84%E6%8B%93%E5%B1%95/">「ES6朝圣」字符串（string）的拓展</a>
                                        <p>
                                            前言
TAG： #字符串加强 #Unicode #遍历字符串 #模版字符串 #编译模版 #标签模版

ES6 中针对 string 拓展了一些很好用的功能，主要分为两大类：

加强对Unicode的支持
没用过就不是前端的模版字符串

我对 Unicode 的了解很少，几乎没在开发中碰见过处理 Unicode 的场景，详细内容嘛待我 Unicode 学成归来，再作分解 👀。
string ...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">January 19, 2022</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2022/01/19/%E3%80%8CLeetCode%E3%80%8D%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6%E3%80%81N%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/">「LeetCode」另一棵树的子树，二叉树的坡度、N叉树的最大深度</a>
                                        <p>
                                            另一棵树的子树
TAG： #相同的树

题目给你两棵二叉树root和subRoot。检验root中是否包含和subRoot具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。
二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。
思路此处只需要去递归检查每棵子树和subRoot是否相同就行了，可以...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">December 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">December 31, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/12/31/%E3%80%8CLeetCode%E3%80%8D%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84%EF%BC%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/">「LeetCode」二叉树的直径，二叉树的最小绝对差</a>
                                        <p>
                                            二叉树的直径
#树 #最大深度 #递归

题目给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
思路在外部定义一个变量 ans 始终存储最大的值；然后开始递归，首先判空，为空返回 0，否则继续；分别递归该节点的左右子树，返回其高度将 ans 与左子树高度加右子树高度再加一的和(题干提到最终结果是取任意两个结点路...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">December 13, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/12/13/%E3%80%8CLeetCode%E3%80%8D%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/">「LeetCode」树中的众数、二叉搜索树的最小绝对差</a>
                                        <p>
                                            树的众数题目给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。
假定 BST 有如下定义：

结点左子树中所含结点的值小于等于当前结点的值
结点右子树中所含结点的值大于等于当前结点的值
左子树和右子树都是二叉搜索树

例如：给定 BST [1,null,2,2]，返回[2]。
思路建立一张hash表，将树节点的值作为key放入其中，value作为该ke...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">December 10, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/12/10/%E3%80%8C%E6%B3%A5%E6%BD%AD%E6%89%93%E6%BB%9A%E3%80%8Dwindow-open%E7%9A%84%E5%A5%87%E5%A6%99%E5%86%92%E9%99%A9/">「泥潭打滚」window.open()的奇妙冒险</a>
                                        <p>
                                            前言一个简单的优化需求，竟然引发了window.open()的奇妙化学反应 ☠️
背景项目 X 的 A 页面需要点击一个区域后，跳转到对应的页面 B，这个页面需要新开窗口来展示。B 页面成功打开后再起接口还在 loading 的时候关闭，会造成当前浏览器中所有项目 X 的页面卡死；反之当 B 页面所有接口 loading 完成后再关闭就不会卡死 😅。这里跳转尝试了多种方式——window....
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">November 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 27, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/27/%E3%80%8CJS%E7%BA%A2%E5%AE%9D%E4%B9%A62%E3%80%8D%E4%BC%9A%E7%94%A8%E5%AE%83%E7%9A%84%E4%BD%A0%E5%B7%B2%E7%BB%8F%E6%98%AF%E5%8D%8A%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%A4%A7%E4%BD%AC%E4%BA%86%EF%BC%81/">「JS红宝书2」会用它的你已经是半个前端大佬了！</a>
                                        <p>
                                            前言将 JavaScript 引入网页,首先要解决的就是它和网页的主导语言 HTML 的兼容性问题。在 JavaScript 早期，Netscape 的大佬们希望将 JavaScript 引入 HTML 的同时，不会导致页面渲染出现问题，通过反复的试验和讨论，他们最终达成了向网页中引入通用脚本能力的共识。以现在的眼光看，当初他们很多成果都以 HTML 规范的形式保留了下来。
&lt;scri...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 17, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/17/%E3%80%8CLeetCode%E3%80%8D%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%8D%E8%BD%AC%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E7%A5%96%E5%85%88%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/">「LeetCode」二叉树的反转、二叉树的最近祖先、二叉树的所有路径、二叉树左叶子之和</a>
                                        <p>
                                            二叉树的反转题目翻转一棵二叉树。
思路思路很简单～
首先，判断一下节点是否为空，为空就返回null；
否则创建一个节点，将当前的节点的值赋给树节点的值，左右节点交换递归；（整个过程自上而下）
代码/**
 * @param &#123;TreeNode&#125; root
 * @return &#123;TreeNode&#125;
 */

var invertTree = funct...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 15, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/15/%E3%80%8CLeetCode%E3%80%8D%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C%E3%80%81%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86/">「LeetCode」路径之和、前序遍历、后续遍历</a>
                                        <p>
                                            路径之和题目给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
叶子节点 是指没有子节点的节点。
思路设置一个数组用来存每棵子树的和；
然后递归去计算每棵子树的高度；
首先会传入根节点 root 和一个初始值 0；
判断节点是否为空，为空就返回 0，否则就累加当前...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 11, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/11/%E3%80%8CLeetCode%E3%80%8D%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E3%80%81%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6%E3%80%81%E5%88%A4%E6%96%AD%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/">「LeetCode」树的最大深度、树的最小深度、判断平衡二叉树、将有序数组转化为二叉搜索树</a>
                                        <p>
                                            前言凑齐一波 LeetCode 热门 Eazy 算法儿（再次狐化 🦊），这波是关于树深度的题目——最大&#x2F;最小深度、判断平衡二叉树、将有序数组转化为二叉搜索树 🎉🎉。
树的最大深度题目给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
思路判断传入的节点是否为空，为空就返回 0；不为空就去计算它左子...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 10, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/10/%E3%80%8CJS%E7%BA%A2%E5%AE%9D%E4%B9%A61%E3%80%8DJS%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/">「JS红宝书1」JS的前世今生</a>
                                        <p>
                                            前言这篇文章是 JS 考古这个系列的开篇之笔。
这一系列主要是参考 Nicholas C.Zakas 所著由李松峰、曹力两人所译的 JavaScript 高级程序设计一书（其实就是学习笔记啦 🤡）。这篇文章主要介绍下面这些内容：

JS 的简史
JS 的三大组成部分：ECMAScript、DOM、BOM

JS 诞生之路JS 的出生背景：1995 年前，是绝大多数人网速还停留在 28.8k...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 03, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/03/%E3%80%8CLeetCode%E3%80%8D%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E3%80%81%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%E3%80%81%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/">「LeetCode」中序遍历、相同的树、对称二叉树</a>
                                        <p>
                                            前言凑齐一波 LeetCode 热门 Eazy 算法儿（狐化 🦊），本期嘉宾为二叉树的中序遍历、相同的树、对称二叉树 🎉🎉
二叉树的中序遍历题目给定一个二叉树的根节点 root ，返回它的 中序 遍历。
思路通过递归去取节点的值，每次递归先判断这个节点是否为空，为空则不继续遍历。由于是中序遍历，所以遍历的顺序是左子树-&gt;根节点-&gt;右子树（这条规则是针对参与中序遍历的树的，例...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 01, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/11/01/%E3%80%8CLeetCode%E3%80%8D%E5%9B%9E%E6%96%87%E6%95%B0%E3%80%81%E7%BD%97%E9%A9%AC%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97/">「LeetCode」回文数、罗马数的计算</a>
                                        <p>
                                            回文数题目给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
思路
可以理解为回文数是数的反转中的一种极端情况

字符串反转法：将传入的 number 转化为 string，然后将其反转后直接比对新的字符串和原始字符串是否相同。
计算法：通过对原始值...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">October 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">October 31, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/10/31/%E3%80%8CLeetCode%E3%80%8D%E6%95%B0%E7%9A%84%E5%8F%8D%E8%BD%AC/">「LeetCode」数的反转</a>
                                        <p>
                                            题目给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围为大于 -2 的 31 次方，小于 2 的 31 次方减 1 ，如果不在范围内就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
思路字符串法：将传入的 number 转化为 string，然后将 string 反转即可。
计算法：通过对传入的 nu...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">October 23, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/10/23/%E3%80%8CLeetCode%E3%80%8D%E6%9D%A5%E8%87%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%AF%92%E6%89%93/">「LeetCode」来自字节的毒打</a>
                                        <p>
                                            前言周五面了字节，面试官很善良，对我进行了长达一小时的毒打。大体过程基本如下：
面试官：这个 xxx 你了解吗？
我：嗯了解，这个 xxx 是巴拉巴拉巴拉巴拉，我们会巴拉巴拉巴拉去用这个 xxx…(省略一堆东西)
面试官：那你能说一下 xxx 里的 xxxx 和 yyyy 有什么区别吗？
我：额，是巴拉巴拉拉巴拉巴？↗️↘️
面试官：能具体一点吗？比如说为什么要这么用，或者什么时候用？
我：...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">September 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">September 19, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/09/19/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DGenerator%E4%B8%8E%E5%BC%82%E6%AD%A5%E4%B8%8EJS/">「ES6朝圣」Generator与异步与JS</a>
                                        <p>
                                            前言前情回顾，结束了 C 端的魔鬼排期，开发倒是闲下来了。我这边基建做得差不多也没有新任务，遂带薪学习 😇
学习新知识，争做新青年！💪
What is 异步？异步概念简单来讲，异步就是不是一步到位，一个任务分为多段执行，比如做饭首先你得煮饭，煮饭的时候你可以洗菜切菜，你准备好菜后就可以炒菜，算好时间炒完菜正好饭就煮好了就可以吃了，这种非连续执行的过程就是异步。反之，需要连续执行的，中间不...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">September 17, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/09/17/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DES6%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%AB%98%E7%BA%A7%E4%B8%80%E7%82%B9%E7%9A%84%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/">「ES6朝圣」Generator高级一点的浅入浅出</a>
                                        <p>
                                            前言时过境迁，C 端魔鬼迭代迎来一小段 🈳️ 闲时间，趁这会儿赶紧把 Generator 剩余的内容更了。
yield*一般情况，在 generator 中调用另外一个 generator 需要手动遍历。ES6 中提供了一种更简洁的方式在 generator 内部执行另一个 generator。其实使用过后不难看出yield*是 for…of…的一种简写形式，这里存在一个问题，如果yiel...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">September 12, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/09/12/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DGenerator%E5%9F%BA%E7%A1%80%E7%9A%84%E6%B5%85%E5%87%BA/">「ES6朝圣」Generator基础的浅出</a>
                                        <p>
                                            前言研究了一段时间 Generator，发现它和 Promise 一个级别的咖位。Generator 能给任何数据结构部署 Symbol.iterator 接口，且不像 Iterator 那般麻烦，同时也是异步编程同步化的一种解决方案，上一个提到的是谁 🤔，不就是 Promise 吗 🤭
时隔一个多月没更新博客了，这段时间实在太忙了，B 端需求一出就去支援 C 端了，本来原定计划的 Ge...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">August 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">August 21, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/08/21/MacBook%E4%B8%80%E6%97%A5%E6%B8%B8/">MacBook一日游</a>
                                        <p>
                                            小记Mac配置前端环境前言我的老Win本已经用了快接近四年的时间，前段时间电池光荣牺牲了，加上在公司尝到Mac的香，于是一咬牙一跺脚换了台m1的MacBook Air😖钱包君直接当场去世。
新电脑一到，首当其冲要做的便是配置开发环境。从Win转到Mac很多操作也要跟着变，不过咱作为开发可不能嫌麻烦啊😊生产力，开冲！
软件清单
git（MacBook原生提供）
node，npm（安装时需要...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">July 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">July 29, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/07/29/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DIterator%E4%B8%80%E6%97%A5%E6%B8%B8/">「ES6朝圣」Iterator一日游</a>
                                        <p>
                                            前言Iterator 可以让你在遍历的领域更加融会贯通，同时是学习 Generator 的前奏。虽然但是所以，为了 Generator，学习吧 NOOB !
Iterator 的概念Iterator 是 ES6 的一种机制，你也可以理解为它是一类接口，给不同数据结构提供统一访问方式。凡是部署了 Iterator 接口的数据结构都能被遍历。
Iterator 的遍历过程：

创建一个指针对象，...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">July 20, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/07/20/%E3%80%8C%E6%B3%A5%E6%BD%AD%E6%89%93%E6%BB%9A%E3%80%8Dxterm-React-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">「泥潭打滚」xterm，React，生命周期</a>
                                        <p>
                                            前言
前排提示： 这篇文章主体是 xterm + React 的实践，带上了一点生命周期的问题，如果单纯是想看 React 生命周期的同学可以退出了 🤺

这周迭代任务完成的比较快，恰逢搞技术基建的大佬需要前端支援，leader 就直接把我借给大佬用了。需求其实很简单，给我们的内部平台做一个 Web-Shell，具体一点就是通过 xterm 来实现前端效果和原生 WebSocket 来与后...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">July 15, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/07/15/%E5%85%B3%E4%BA%8E%E6%88%91%E4%B8%8A%E7%8F%AD%E4%B8%A4%E4%B8%AA%E6%9C%88%EF%BC%8C%E8%8F%9C%E7%9A%84%E5%B7%AE%E7%82%B9%E5%89%8D%E5%BE%80%E5%BC%82%E4%B8%96%E7%95%8C/">关于我上班两个月，菜的差点直接转生到异世界</a>
                                        <p>
                                            前情提要来柚子鸭刚好两个月出头，这次迭代是我参与的第四次迭代。这篇文章也是围绕这次迭代，本迭代我的第一个需求的大致背景是对一个表单页中的可编辑表格进行改造，添加一列上传图片的组件。完成这个需求和解决相关缺陷的过程反映这段时间我的成长和目前自身存在的问题，抽个时间来总结总结。
下面由我本色出演！🙋‍♂
环境
框架： React
组件： Antd， Antd Pro

见招拆招🤡
功能点详情...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">July 12, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/07/12/Nginx%E7%9A%84%E6%B5%85%E5%87%BA/">Nginx的浅出</a>
                                        <p>
                                            前言
本文不会实践拦截恶意请求和高可用集群，后续会单独出文章

1202年了，干前端的都去卷后端了。干前端的多多少少都得了解nginx相关的知识。nginx作为一款轻量且高性能的开源服务软件备受各大大厂的青睐，下至反向代理，动静分离提升你的开发体验和项目性能；上至拦截恶意请求、高可用集群，为你的服务保驾护航。
Nginx的相关概念正向代理提反向代理前，要先提一嘴正向代理。正向代理模式下，客户...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">July 02, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/07/02/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DPromise%E4%B9%8B%E5%AD%A6%E4%BA%86%E5%8F%88%E5%AD%A6/">「ES6朝圣」Promise2.0之学了又学</a>
                                        <p>
                                            前言
Promise-1.0

同解构赋值一样，ES6 最出名的特性之一。你在接触 ES6 之前或多或少都听说 Promise，或者在一些工具库里也体验过了 Promise。
Promise 的概念
概念

Promise 最早是由 JS 社区提出和实现的，在 ES6 中被写入规范大纲。Promise 是一种同步处理异步问题的解决方案，其本身相当于一个容器与它的上下文是同步的关系，内部放入一...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">June 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">June 28, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/06/28/%E3%80%8C%E6%B3%A5%E6%BD%AD%E6%89%93%E6%BB%9A%E3%80%8DAntd%E7%9A%84Tag%E7%BB%84%E4%BB%B6%E8%B8%A9%E5%9D%91/">「泥潭打滚」Antd的Tag组件踩坑</a>
                                        <p>
                                            前言
先说结论，给 Tag 设置 Key，如果同时存在删除和重排的操作就不要用 index 来设置。

需求涉及的表单控件需要一个可多选的级联组件，恰巧 Antd 的级联组件（Cascader）没有提供多选相关的功能，遂只能自己封装。这里的封装思路是用一个数组来管理每个选项的数据，使用 Antd 的Tag组件来展示。Tag组件上提供了onClose方法来删除Tag。问题就来了，当我点击删除T...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">June 16, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/06/16/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8D%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/">「ES6朝圣」解构赋值</a>
                                        <p>
                                            前言解构赋值绝对是 ES6 带来最好用以及现在最常用的功能之一！
数组解构只要数据的数据解构存在 Iterator 接口，它就能被解构。

基本用法

const [one, two, three] = [1, 2, 3];

console.log(one, two, three);

// 1, 2, 3


真相只有一个

const [ badGuy, goodGuy ] = [ &...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">June 12, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/06/12/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DES6%E5%AD%A6%E4%B9%A0%E5%BC%80%E7%AF%87/">「ES6朝圣」ES6简介</a>
                                        <p>
                                            前言ES6，全名ECMAScript 6.0，是 ECMA（European Computer Manufactures Association）组织在 2015 年 6 月发布的标准。
ECMAScript 与 JavaScript 的关系
ECMAScript 是怎么来的？

1996 年 11 月 JS 的创造者网景（NetScape）公司将 JS 提交给 ECMA，希望 JS 能成为...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">May 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">May 31, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/05/31/%E5%A6%82%E4%BD%95%E7%94%A8%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95%E6%9D%A5%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81/">如何工程化你的代码</a>
                                        <p>
                                            前言团队成员代码风格不统一💩 、BAD CODE被部署上线💩 、团队编码规范难以落地💩 、代码质量参差不齐💩 ，这些问题是协同开发中经常出现的痛点。这篇文章会一步一步教你的配置ESLint，Prettier，Husky，Lint-Staged (有手就会🙌)。这些工具会在你开发的时候帮你规避掉一些痛点，同时让你慢慢养成代码”洁癖”😊 
流程
git add .
git commi...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">May 27, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/05/27/%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E4%B8%8E%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6%E6%B5%85%E5%87%BA/">受控组件与非受控组件浅出</a>
                                        <p>
                                            前言在实习期间参与的第一个版本迭代中，我分到的需求有编辑相关的功能，我思路几乎都是通过ref去获取表单控件的值再去修改（非受控组件），中间碰了很多壁😭遂来研究受控和非受控组件。
概念在React中，一般推荐使用受控组件，因为受控组件的状态和方法一般都是由顶层组件来维护，拓展性显而易见的好。当然也不是说受控组件好就要全部使用受控组件，比如file类型表单控件的值只能由用户传入，因此只能是非受...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">May 14, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/05/14/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8Dlet%E4%B8%8Econst%E8%AF%A6%E8%A7%A3%E5%8F%8AEs6%E4%B8%AD%E9%A1%B6%E5%B1%82%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E5%8F%98%E5%8C%96/">「ES6朝圣」let与const详解及ES6中顶层对象相关变化</a>
                                        <p>
                                            letlet 的用法就像 ES5 中的 var 一样，但是不允许在一个作用域内重复声明
var ZS = &quot;ZhangSan&quot;;
let LS = &quot;LiSi&quot;;

var ZS = &quot;JiaZhangSan&quot;; // 覆盖掉ZhangSan
let LS = &quot;JiaLiSi&quot;; // SyntaxError
...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">May 04, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/05/04/%E7%99%BE%E8%AF%8D%E6%96%A9%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E9%9D%A2%E8%AF%95/">百词斩前端实习面经——面试</a>
                                        <p>
                                            准备👨大概花了两周的时间准备，其实算下来只有一周多一点中间还是隔断的，因为面试在第八周，第八周正好有两门课要结课，所以没怎么准备。复习了HTML，CSS，JS，Vue，网络，以及前端要考虑处理的问题，如变量提升、防抖节流、回流重绘、如何应对XSS和CSRF攻击之类的问题。
笔试百词斩前端实习——笔试
面试
面试官是个程序媛，问的有水平👍👍👍本来说开录屏把整个面试过程录下来，之后好整理...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">April 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 26, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/26/%E7%99%BE%E8%AF%8D%E6%96%A9%E5%89%8D%E7%AB%AF%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F%E2%80%94%E2%80%94%E7%AC%94%E8%AF%95/">百词斩前端实习面经——笔试</a>
                                        <p>
                                            题目要求写一个函数，传入一个带有数字的字符串，经过处理后输出字符串里最大的数字，要求字符串长度不能超过1024，数字的大小不能超过21xxxxxx（反正很大的一个数）
求解function getMaxInString(str) &#123;
    if(str.length &gt; 1024) return

    let maxNum = 0;
    /** 
    * 正则全...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 08, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/08/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/">响应式布局</a>
                                        <p>
                                            前言在智能移动设备刚开始发展的时候，人们访问 Web 网页的时候只能看到占满视窗大小的 PC 页面，可以通过缩放来浏览。如今移动设备在日程生活的比重已然到 TOP1 , Web 网页针对移动设备的体验也有了质的飞跃。在布局结构不那么复杂的网站通常会使用响应式布局（ Responsive Layout ）；而较为复杂的页面，会选择做双栈，通过JS来获取设备信息来进行跳转。
meta标签我们会在...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 04, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/04/%E3%80%8CReactHooks%E3%80%8D%E8%87%AA%E5%AE%9A%E4%B9%89Hook/">「ReactHooks」自定义Hook</a>
                                        <p>
                                            前言自定义 Hook ——&gt; 当我们在两个及两个以上的函数内有共享的状态逻辑的时候就可以使用自定义 Hook 将这部分重复的逻辑给单独抽离出来。
写法自定义 Hook 必须以use开头，不遵循的话，由于无法判断某个函数是否包含对其内部 Hook 的调用，React 将无法自动检查你的 Hook 是否违反了 Hook 的规则。自定义 Hook 的参数与返回值可以由我们自由决定。
案例这个...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 04, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/04/%E3%80%8CReactHooks%E3%80%8DuseRef%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6/">「ReactHooks」useRef基础到进阶</a>
                                        <p>
                                            前言useRef 可以通过 ref 获取 DOM 节点，其次它还有保存变量的特性。
useRef 基础写法useRef 的写法为useRef(initialValue)，其会返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。

请记住，当 ref 对象内容发生变化时，useRef 并不...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 03, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/03/%E3%80%8CReactHooks%E3%80%8DuseMemo%E5%9F%BA%E7%A1%80/">「ReactHooks」useMemo基础</a>
                                        <p>
                                            前言useMemo 有助于避免在每次渲染时都进行高开销的计算，能帮助开发者更好的对组件进行颗粒化。
useMemo 基础写法useMemo 把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。写法为useMemo( ()=&gt;avoidFunction(), [...dependences])，第一个参数为需要避免重渲染的函数...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 03, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/03/%E3%80%8CReactHooks%E3%80%8DuseReducer%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6/">「ReactHooks」useReducer基础到进阶</a>
                                        <p>
                                            前言useReducer 是让无状态组件中运行的类似 redux 的功能 API 。
useReducer 基础写法useReducer 的写法为const [state, dispatch] = useReducer(reducer, initialArg, init)，第一个参数 reducer （必填），其写法和 redux 的 reducer 类似，是一个方法，通过 action.t...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 03, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/03/%E3%80%8CReactHooks%E3%80%8DuseContext%E5%9F%BA%E7%A1%80/">「ReactHooks」useContext基础</a>
                                        <p>
                                            前言useContext 让开发者能更方便的处理隔多代组件的传值问题。useContext 可以获取父级组件传递过来的 context 值，这个当前值就是最近的父级组件 Provider 设置的 value 值，useContext 参数必须是 Context 对象本身。
初识contextType/* 创建Context对象 */
const Context = createContext...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 02, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/04/02/%E3%80%8CReactHooks%E3%80%8DuseEffect%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6/">「ReactHooks」useEffect基础到进阶</a>
                                        <p>
                                            前言在 React 一开始 function 组件主体内副作用操作（如改变 DOM、添加订阅、设置定时器、记录日志等操作–&gt;副作用）是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。useEffect 的出现更高效的解决了在开发时的这些问题。
初识class 组件( componentDidMount，componentDidUpdate )class App ...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">March 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">March 28, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/03/28/%E3%80%8CReactHooks%E3%80%8DuseState%E5%9F%BA%E7%A1%80%E5%88%B0%E8%BF%9B%E9%98%B6/">「ReactHooks」useState基础到进阶</a>
                                        <p>
                                            前言useState 可以让无状态组件拥有自己的 state，以及派发更新 state 方法。useState 传入的参数是赋给 state 的初始值，可以是具体的值，也可以是一个有复杂逻辑处理的方法。
useState 基础写法useState 写法为 const [ state, setState ] = useState( InitialState ) 。useState 传入一个初始...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">March 24, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/03/24/%E3%80%8CLeetCode%E3%80%8D132%E6%A8%A1%E5%BC%8F/">「LeetCode」132模式</a>
                                        <p>
                                            给定一个整数序列：a1, a2, …, an，一个 132 模式的子序列 ai, aj, ak 被定义为：当 i &lt; j &lt; k 时，ai &lt; ak &lt; aj。设计一个算法，当给定有 n 个数字的序列时，验证这个序列中是否含有 132 模式的子序列。
我的思路思路是枚举三个数，妥妥的超时。定义一个函数每次放入三个数来比较，如果不符合 132 模式且数组还有剩余，就把栈...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">March 23, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/03/23/%E3%80%8CLeetCode%E3%80%8D%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/">「LeetCode」扁平化嵌套列表迭代器</a>
                                        <p>
                                            给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。
我的思路这道题思路是利用深度优先（DFS）来解，但 JS 迭代器那块的了解不够，没有解出来，现在已搞懂。官答的两种方案的一种也是利用 DFS 来解，还有一种是利用栈来解决。
踩坑本题定义了一个 NestedInteger ...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">March 22, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/03/22/%E3%80%8CLeetCode%E3%80%8D%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/">「LeetCode」位1的个数</a>
                                        <p>
                                            编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数。
我的思路这道题没有解出来，归根于对 JavaScript 处理二进制参数的机制不熟悉，现在已经搞懂。官方的思路是：定义一个 ret 变量管理 1 出现的次数，由于给的二进制数据是 32 位定长的，所以循环 32 次，每次让 1 向左偏移 1 位后与传入的二进制数据比较，比对成功就 ret...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">March 22, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/03/22/%E3%80%8CLeetCode%E3%80%8D%E7%9F%A9%E9%98%B5%E7%BD%AE0/">「LeetCode」矩阵置0</a>
                                        <p>
                                            给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0。

我的思路将矩阵每行遍历一遍，去找 0 的列位置，找到之后单独用一个数组管理起来，只要有 0 我们最后的时候就直接把整行置为 0。然后去设置列，将每行中的列位置（刚刚记录的）数字置为 0。
我的代码var setZeroes = function (matrix) &#123;
  //定义一个数组管...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">March 21, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/03/21/%E3%80%8CLeetCode%E3%80%8D%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97/">「LeetCode」逆波兰表达式运算</a>
                                        <p>
                                            逆波兰表达式：
逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：
去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">February 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 18, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/18/%E3%80%8CLeetCode%E3%80%8DK%E8%BF%9E%E7%BB%AD%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BF%BB%E8%BD%AC%E6%AC%A1%E6%95%B0/">「LeetCode」K连续位的最小翻转次数</a>
                                        <p>
                                            在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。
我的思路由题推断处理数组的次数不会多过他自己的长度，因此我们循环传入的数组，每次处理我们循环判断一下数组里的 0 和 1 的个数，如果 1 的个数...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 17, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/17/%E3%80%8CLeetCode%E3%80%8D%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/">「LeetCode」重塑矩阵</a>
                                        <p>
                                            在 MATLAB 中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。给出一个由二维数组表示的矩阵，以及两个正整数 r 和 c，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。
我的思路把要处理...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 15, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/15/Vue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E4%B8%8E%E9%83%A8%E5%88%86%E5%B1%9E%E6%80%A7%E5%8E%9F%E7%90%86/">Vue双向绑定与部分属性原理</a>
                                        <p>
                                            引言之前写过一篇文章是关于使用ES6的proxy来实现一个快速创造Dom的简单框架。这篇文章算是一个进阶，用原生JS实现Vue视图层和数据层的双向绑定。
准备在你的根目录创建一个js文件和html文件。js用于封装我们的Vue对象，html则是我们完成了js的编写后在里面测试。
创建对象创建一个Vue类，之后我们通过里面构造器来实例化Vue对象。在使用Vue框架（正房）的时候通常会在里面传入...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 14, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/14/%E3%80%8CLeetCode%E3%80%8D%E6%83%85%E4%BE%A3%E7%89%B5%E6%89%8B/">「LeetCode」情侣牵手</a>
                                        <p>
                                            N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。
人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。
这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 13, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/13/%E3%80%8CLeetCode%E3%80%8D%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0/">「LeetCode」找到所有数组中消失的数</a>
                                        <p>
                                            给定一个范围在 1 ≤ a[i] ≤ n ( n &#x3D; 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。
我的思路拿到 [1, n]所有数，判断其在不在输入的 nums 数组中，然后对其作相应的操作
我的代码/**
 * @param &#123;number[]&#125; nums
 * @ret...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 12, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/12/%E3%80%8CLeetCode%E3%80%8D%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%922/">「LeetCode」杨辉三角2</a>
                                        <p>
                                            给定一个非负索引 _k_，其中 k ≤ 33，返回杨辉三角的第 k 行。

我的思路先按层处理，然后操作层内。已知层数，推出每层数的个数为层数+1。通过层层计算我们只需要保存上一层(父亲层)就能计算出下一层(儿子层
我的代码/**
 * @param &#123;number&#125; rowIndex
 * @return &#123;number[]&#125;
 */
var get...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">February 11, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/02/11/SOCKET.IO%E7%9A%84%E6%B5%85%E5%87%BA/">SOCKET.IO的浅出</a>
                                        <p>
                                            引言SOCKET.IO是一个库，其又分为client客户端库与server服务端库。前者在前端配置使用，后者在后端配置使用。SOCKET.IO可以让我们的浏览器建立实时，双向和基于事件的通信，由此我们可以基于SOCKET.IO开发聊天APP、点餐APP、快递APP等等一些需要客户端和服务端建立通信连接的APP。
WebSocket与SOCKET.IOWebScoket：是一种让客户端和服务器...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">January 2021</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">January 31, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/01/31/%E7%AD%89%E5%AE%BD%E7%80%91%E5%B8%83%E6%B5%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%85%B6%E5%8E%9F%E7%A0%81/">等宽瀑布流实现思路及其原码</a>
                                        <p>
                                            引言在我的express  + ejs + mysql 个人博客项目中，分享页面实现了等宽瀑布流渲染照片这一功能。等宽瀑布流，字如其名就是我们要渲染宽度相同，高度不同的内容。等宽瀑布流比起等高瀑布流有个好处就是开发过程中不用在意图片的比例，缺点目前我觉得就是JavaScript操作比等高瀑布流多很多，等高瀑布流多数操作可以通过css来完成，但是需要考虑图片比例变化来带的视觉问题。在这儿分享我...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">January 27, 2021</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2021/01/27/%E8%A7%A3%E5%86%B3IMG%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E9%97%AE%E9%A2%98/">解决IMG对象创建过程中的异步问题</a>
                                        <p>
                                            引言该文章是基于我自己用express  + ejs + mysql 搭建的个人博客项目。在开发过程中，图片对象异步创建导致了获取宽高的代码不会立即执行，所以后续的第一次循环（因为请求图片肯定是一组一组的请求，请求一组图片再循环对每张图片操作）拿不到计算过后的准确top值（此处在实现等宽瀑布流，需要计算图片的top值），直接使首次请求的部分图片渲染失败。现在给出以下两种解决思路。这里只提供思...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">December 2020</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">December 27, 2020</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2020/12/27/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8Dthis%E8%AF%A6%E8%A7%A3/">「ES6朝圣」this详解</a>
                                        <p>
                                            概念解析器在调用函数的时候，每次都会向函数内部传入两个隐含参数，其中一个是 this。this 的指向是一个对象，这个对象称为函数执行时的 上下文对象 。
this 的指向根据函数的调用方式不同，this 的指向也会不同。

以函数fuction()来调用，this 永远指向 window。
以方法来调用，this 指向调用方法的对象。

var user = &#123;
    name...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">November 2020</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">November 14, 2020</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2020/11/14/Proxy%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6/">Proxy实现简易框架</a>
                                        <p>
                                            Proxy基础
概念

可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

案例

let userObj = &#123;
    name: &quot;张三&quot;,
    age: 18
&#125;

//创建一个新的Proxy对象，第一个参数传要代理的对象，第二个参数传要执行的内容
l...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">July 2020</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">July 14, 2020</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2020/07/14/jQuery%E5%8E%9F%E7%90%86/">jQuery原理</a>
                                        <p>
                                            $的封装       //定义$符号
    //传入选择器
   let $ = function (selector) &#123;
      //获取dom节点
      let doms = document.querySelectorAll(selector);
      //返回dom节点
      return doms
    &#125;

添加html方法  le...
                                        </p>
                                    </div>
                                </li>
                            
                                
                                <li class="timeline-item period">
                                    <div class="timeline-info"></div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <h2 class="timeline-title">April 2020</h2>
                                    </div>
                                </li>
                                
                                <li class="timeline-item">
                                    <div class="timeline-info">
                                        <span class="gradient-text">April 21, 2020</span>
                                    </div>
                                    <div class="timeline-marker"></div>
                                    <div class="timeline-content">
                                        <a class="timeline-title" target="_self" href="/2020/04/21/%E3%80%8CES6%E6%9C%9D%E5%9C%A3%E3%80%8DAsync%E4%B8%8EPromise%E6%80%BB%E7%BB%93/">「ES6朝圣」Async与Promise总结</a>
                                        <p>
                                            Async 和 Promise 的不同写法ES5 写法
getAjax(url, (res) =&gt; &#123;
  console.log(&quot;我是回调&quot;);
&#125;);

Promise 写法
get(url).then((res)=&gt;&#123;
    console.log(&quot;我是回调&quot;);
&#125;))

Async 写...
                                        </p>
                                    </div>
                                </li>
                            
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2020
        <!-- <span class="gradient-text">
            Lee 62
        </span>. -->
        Powered by <span class="gradient-text">Lee 62</span>
        <!-- <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a>
        Theme
        <span class="gradient-text">
            <a href="https://github.com/TriDiamond/hexo-theme-obsidian" title="Obsidian" target="_blank" rel="noopener">Obsidian</a>
        </span>
        <small><a href="https://github.com/TriDiamond/hexo-theme-obsidian/blob/master/CHANGELOG.md" title="v1.4.7" target="_blank" rel="noopener">v1.4.7</a></small>
        
         -->
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>


 
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>
 
<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>
 
<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>
 
<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>
 
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>
  
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>
   
<script src="/js/busuanzi.min.js"></script>

<script>
  $(document).ready(function () {
    if ($('span[id^="busuanzi_"]').length) {
      initialBusuanzi();
    }
  });
</script>
 
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>
 
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag('js', new Date());

  gtag('config', 'UA-149874671-1');
</script>
 

<script>
  function initialTyped() {
    var typedTextEl = $('.typed-text');
    if (typedTextEl && typedTextEl.length > 0) {
      var typed = new Typed('.typed-text', {
        strings: ['Think like an artist, develop like an artisan', '艺术家思维去思考问题，工匠创造精神去开发'],
        typeSpeed: 90,
        loop: true,
        loopCount: Infinity,
        backSpeed: 20,
      });
    }
  }

  if ($('.article-header') && $('.article-header').length) {
    $(document).ready(function () {
      initialTyped();
    });
  }
</script>






</html>
